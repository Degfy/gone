package mock

import (
	"bufio"
	"fmt"
	"github.com/pkg/errors"
	"github.com/urfave/cli/v2"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

//for modify mock codeï¼Œ add `gone.flag` to MockStructure

var Command = &cli.Command{
	Name:        "mock",
	Usage:       "-f ${fromGoFile} -o ${outGoFile}",
	Description: "patch code which is generated by github.com/golang/mock/mockgen, add `gone.flag` to MockStructure",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name:  "f",
			Usage: "FromGoFile",
		},
		&cli.StringFlag{
			Name:     "o",
			Usage:    "outGoFile",
			Required: true,
		},
	},
	Action: action,
}

func action(ctx *cli.Context) error {
	outfilePath := ctx.String("o")
	err := os.MkdirAll(filepath.Dir(outfilePath), os.ModePerm)
	if err != nil {
		return err
	}

	outFile, err := os.Create(outfilePath)
	if err != nil {
		return err
	}

	defer outFile.Close()

	if isInputFromPipe() {
		return patchMock(os.Stdin, outFile)
	} else {
		file, e := getFile(ctx.String("f"))
		if e != nil {
			return e
		}
		defer file.Close()
		return patchMock(file, outFile)
	}
}

func isInputFromPipe() bool {
	fileInfo, _ := os.Stdin.Stat()
	return fileInfo.Mode()&os.ModeCharDevice == 0
}

func getFile(filepath string) (*os.File, error) {
	if filepath == "" {
		return nil, errors.New("please input a file")
	}

	if existed, err := fileExists(filepath); existed && err != nil {
		return nil, errors.New("the file provided does not exist")
	}

	file, e := os.Open(filepath)

	if e != nil {
		return nil, errors.Wrapf(e, "unable to read the file %s", filepath)
	}
	return file, nil
}

var preMatchReg = regexp.MustCompile("is a mock of .+? interface.")

func patchMock(r io.Reader, w io.Writer) error {
	reader := bufio.NewReader(r)

	var preMatchFlag bool

	for {
		line, _, err := reader.ReadLine()
		if err == io.EOF {
			break
		}

		_, err = w.Write(line)
		if err != nil {
			return err
		}

		_, _ = w.Write([]byte("\n"))

		lineStr := string(line)

		if strings.HasPrefix(lineStr, "import (") {
			_, err = w.Write([]byte("\tgoneMock \"github.com/gone-io/gone\"\n"))
			if err != nil {
				return err
			}
		}
		//fmt.Printf("%s\n", line)

		if preMatchReg.Match(line) {
			preMatchFlag = true
		}

		if preMatchFlag && strings.HasPrefix(lineStr, "type") {
			_, err = w.Write([]byte("\tgoneMock.Flag\n"))
			if err != nil {
				return err
			}
			preMatchFlag = false
		}
	}

	scanner := bufio.NewScanner(bufio.NewReader(r))
	for scanner.Scan() {
		_, e := fmt.Fprintln(w, strings.ToUpper(scanner.Text()))
		if e != nil {
			return e
		}
	}
	return nil
}

func fileExists(filepath string) (bool, error) {
	fileInfo, err := os.Stat(filepath)
	if err != nil {
		// no such file or dir
		return false, err
	}
	if fileInfo.IsDir() {
		return false, nil
	} else {
		return true, nil
	}
}
